name: Build, Release, and Version Check

permissions:
  contents: read

on:
  push:
    branches: [ "*" ]
    tags: [ "v*" ]
  pull_request:
    branches: [ "*" ]

jobs:
  check:
    runs-on: ubuntu-latest
    environment: check

    outputs:
      dllversion: ${{ steps.setversion.outputs.dllversion }}

    steps:
      - uses: actions/checkout@v6
        with:
          sparse-checkout: |
            manifest.json
            ${{ vars.CSPROJ_LOCATION }}
            ${{ vars.BUILDINFO_LOCATION }}
            CHANGELOG.md

      - name: Get version from manifest
        id: setversion
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $version = (Get-Content manifest.json | ConvertFrom-Json).version_number
          Write-Output "VERSIONNUM=$version" >> $env:GITHUB_ENV
          Write-Output "dllversion=$version" >> $env:GITHUB_OUTPUT
          Write-Host "DLLVERSION=$version"

      - name: Check .csproj
        shell: bash
        run: |
          version_number=$(awk -F'[<>]' '/<VersionPrefix>/ {print $3}' ${{ vars.CSPROJ_LOCATION }})
          if [ "$version_number" != "$VERSIONNUM" ]; then
            echo "Error: got version $version_number, expected $VERSIONNUM"
            exit 1
          fi

      - name: Check .cs
        shell: bash
        run: |
          version_number=$(awk -F'"' '/const string ModVersion/ {print $2; exit}' ${{ vars.BUILDINFO_LOCATION }})
          if [ "$version_number" != "$VERSIONNUM" ]; then
            echo "Error: got version $version_number, expected $VERSIONNUM"
            exit 1
          fi

      - name: Check changelog
        shell: bash
        run: |
          if [ "$(head -n 1 CHANGELOG.md)" != "# v$VERSIONNUM" ]; then
            echo "Error: first line of CHANGELOG.md is not '# v$VERSIONNUM'"
            exit 1
          fi

      - name: Check tag
        shell: bash
        if: startsWith(github.ref, 'refs/tags/v')
        run: |
          version_number="${GITHUB_REF#refs/tags/v}"
          if [ "$version_number" != "$VERSIONNUM" ]; then
            echo "Error: got version $version_number, expected $VERSIONNUM"
            exit 1
          fi

  build:
    needs: check
    runs-on: windows-latest
    environment: build

    env:
      LIBSDIRPATH: ${{ github.workspace }}\deps
      DLLVERSION: ${{ needs.check.outputs.dllversion }}
        
    steps:
      - uses: actions/checkout@v6

      - name: Get deps hash
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $dependencies = (Get-Content manifest.json | ConvertFrom-Json).dependencies -join "`n"
          $bytes = [System.Text.Encoding]::UTF8.GetBytes($dependencies)
          $memoryStream = [System.IO.MemoryStream]::new($bytes)
          $hash = Get-FileHash -InputStream $memoryStream -Algorithm SHA256
          $lowerhash = $hash.Hash.ToLower()
          Write-Output "DEPSHASH=$lowerhash" >> $env:GITHUB_ENV
          Write-Host "DEPSHASH=$lowerhash"
          Write-Host "Dependencies:`n$dependencies"

      - name: Restore Thunderstore deps cache
        if: ${{ env.DEPSHASH != '' }}
        id: cache-deps
        uses: actions/cache/restore@v5
        with:
          key: thunderstore-deps-${{ env.DEPSHASH }}
          path: ${{ env.LIBSDIRPATH }}

      - name: Download dependencies
        if: steps.cache-deps.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $deps = (Get-Content manifest.json | ConvertFrom-Json).dependencies
          New-Item -ItemType Directory -Force -Path $env:LIBSDIRPATH | Out-Null
          foreach ($dep in $deps) {
            $parts = $dep -split '-'
            $user = $parts[0]; $pkg = $parts[1]; $ver = $parts[2]
            $url = "https://thunderstore.io/package/download/$user/$pkg/$ver"
            $out = Join-Path $env:LIBSDIRPATH "$($user)-$($pkg)-$($ver).zip"
            Write-Host "Fetching $url â†’ $out"
            Invoke-WebRequest -Uri $url -OutFile $out
          }

      - name: Unzip dependencies
        if: steps.cache-deps.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $detectionPath = Join-Path $env:LIBSDIRPATH "*.zip"
          Get-ChildItem $detectionPath | ForEach-Object {
            $zip = $_.FullName
            Write-Host "Extracting $zip"
            Expand-Archive -Path $zip -DestinationPath $env:LIBSDIRPATH -Force
          }

      - name: Clean files in deps
        if: steps.cache-deps.outputs.cache-hit != 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $removedFiles = Get-ChildItem -Path $env:LIBSDIRPATH -File | Where-Object { $_.Name -ne "version.dll" }
          foreach ($file in $removedFiles) {
            Write-Host "Removing file: $($file.FullName)"
            Remove-Item -Path $file.FullName -Force
          }

      - name: Save Thunderstore deps cache
        if: ${{ env.DEPSHASH != '' && steps.cache-deps.outputs.cache-hit != 'true' }}
        uses: actions/cache/save@v5
        with:
          key: thunderstore-deps-${{ env.DEPSHASH }}
          path: ${{ env.LIBSDIRPATH }}

      - name: Download steamcmd
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          New-Item -ItemType Directory -Path "steamcmdstuff" -Force
          Set-Location steamcmdstuff
          $steamcmdUrl = "https://steamcdn-a.akamaihd.net/client/installer/steamcmd.zip"
          $steamcmdZip = "steamcmd.zip"
          Write-Host "Downloading steamcmd from $steamcmdUrl"
          Invoke-WebRequest -Uri $steamcmdUrl -OutFile $steamcmdZip
          Write-Host "Extracting steamcmd"
          Expand-Archive -Path $steamcmdZip -DestinationPath . -Force

      - name: Install steamcmd
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Set-Location steamcmdstuff
          .\steamcmd.exe +quit
          $code = $LASTEXITCODE
          if ($code -eq 7) {
            Write-Host "SteamCMD returned exit code 7 (ignoring)."
            $code = 0
          }
          exit $code

      - name: Get RUMBLE version
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Set-Location steamcmdstuff
          $output = .\steamcmd.exe +login anonymous +app_info_print 890550 +quit

          $branchesIndex = -1
          for ($i = 0; $i -lt $output.Count; $i++) {
            if ($output[$i] -match '^\s*"branches"\s*$') { $branchesIndex = $i; break }
          }
          if ($branchesIndex -lt 0) {
            Write-Error "Failed to retrieve RUMBLE version."
            Write-Error "No '\"branches\"' block found."
            Write-Host "Output from steamcmd:`n$output"
            exit 1
          }

          $publicIndex = -1
          for ($i = $branchesIndex + 1; $i -lt $output.Count; $i++) {
            if ($output[$i] -match '^\s*"public"\s*$') { $publicIndex = $i; break }
            if ($output[$i] -match '^\s*\}') { break }
          }
          if ($publicIndex -lt 0) {
            Write-Error "Failed to retrieve RUMBLE version."
            Write-Error "No '\"public\"' branch found inside '\"branches\"'."
            Write-Host "Output from steamcmd:`n$output"
            exit 1
          }

          $buildidLine = $null
          for ($i = $publicIndex + 1; $i -lt $output.Count; $i++) {
            if ($output[$i] -match '^\s*"buildid"\s*"[^"]*"\s*$') { $buildidLine = $output[$i]; break }
            if ($output[$i] -match '^\s*\}') { break }
          }
          if ($buildidLine -eq $null) {
            Write-Error "Failed to retrieve RUMBLE version."
            Write-Error "No buildid found inside '\"public\"' branch."
            Write-Host "Output from steamcmd:`n$output"
            exit 1
          }

          $buildid = $buildidLine -replace '.*"buildid"\s+"(\d+)".*', '$1'
          Write-Output "RUMBLEVER=$buildid" >> $env:GITHUB_ENV
          Write-Host "RUMBLEVER=$buildid"
          if (-not $buildid) {
            Write-Error "Failed to retrieve RUMBLE version."
            Write-Error "Could not extract buildid from line: $buildidLine"
            Write-Host "Output from steamcmd:`n$output"
          }

      - name: Cleanup steamcmd
        shell: pwsh
        run: Remove-Item steamcmdstuff -Recurse -Force

      - name: Setup .NET SDK 10
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: '10'

      - name: Install Powershell and 7z
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          winget upgrade winget --accept-package-agreements --accept-source-agreements --disable-interactivity
          # TODO: switch off preview. make sure to change other steps that use preview. also remove install entirely when gh actions supports powershell with .net 10
          winget install Microsoft.PowerShell.Preview --disable-interactivity
          $Url = "https://www.7-zip.org/download.html"
          $Html = Invoke-WebRequest -Uri $Url
          $Html.Content -match 'Download 7-Zip (\d+\.\d+)'
          $ver = $matches[1] -replace '\D', ''
          $link = "https://www.7-zip.org/a/7z$($ver)-x64.msi"
          Write-Host "Installing $($link)"
          $msi = "$env:TEMP\7z.msi"
          Invoke-WebRequest $link -OutFile $msi
          msiexec /i $msi /quiet /norestart
          Write-Host "Installed 7z"

      - name: Checkout assemblies
        uses: actions/checkout@v6
        with:
          repository: plumguardian/il2cppassemblies
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          path: il2cppassembliesrepo

      - name: Setup powershell
        shell: pwsh
        run: echo "C:\Program Files\PowerShell" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Unpack assembly
        shell: 7-preview\pwsh.exe -command "Copy-Item '{0}' '{0}.ps1'; . '{0}.ps1'"
        env:
          IL2CPPASSEMBLIES7ZIPPASSWORD: ${{ secrets.IL2CPPASSEMBLIES7ZIPPASSWORD }}
          PK8_B64: ${{ secrets.PK8 }}
        run: |
          $ErrorActionPreference = 'Stop'
          $unpackDir = "unpackassembly"
          New-Item -ItemType Directory -Path $unpackDir -Force
          $assemblyParent = Join-Path $env:GITHUB_WORKSPACE 'il2cppassembliesrepo'
          $assemblyPath = Join-Path $assemblyParent $env:RUMBLEVER
          Set-Location $unpackDir

          Write-Host "Assembly path: $($assemblyPath)"
          if (-not (Test-Path $assemblyPath)) { throw "Assembly does not exist: $assemblyPath" }
          $inPqc = Join-Path (Get-Location).Path 'stuff.pqc'
          Copy-Item -Path $assemblyPath -Destination $inPqc -Force -ErrorAction Stop
          if (-not (Test-Path $inPqc)) { throw "Input PQC file not found: $inPqc" }

          $decryptDir = Join-Path (Get-Location).Path 'decrypt'
          New-Item -ItemType Directory -Path $decryptDir -Force

          $outExtractDir = Join-Path $env:GITHUB_WORKSPACE 'assembliesout'
          New-Item -ItemType Directory -Path $outExtractDir -Force

          $pk8Dir = Join-Path (Get-Location).Path 'gen'
          $pk8Path = Join-Path $pk8Dir 'key.pk8'
          New-Item -ItemType Directory -Path $pk8Dir -Force

          if (-not $env:PK8_B64) { throw "Secret PK8_B64 not provided." }
          [IO.File]::WriteAllBytes($pk8Path, [Convert]::FromBase64String($env:PK8_B64))

          if (-not [System.Security.Cryptography.MLKem]::IsSupported) {
            throw "ML-KEM not supported on this runner (.NET 10 MLKem API unavailable)."
          }

          $br = [IO.BinaryReader]::new([IO.File]::OpenRead($inPqc))
          $magic = [Text.Encoding]::ASCII.GetString($br.ReadBytes(4))
          if ($magic -ne "PQC1") { throw "Invalid PQC container magic: $magic" }
          $version = $br.ReadByte()
          $ctLen = $br.ReadInt32()
          $ct = $br.ReadBytes($ctLen)
          $nonceLen = $br.ReadInt32()
          $nonce = $br.ReadBytes($nonceLen)
          $tagLen = $br.ReadInt32()
          $tag = $br.ReadBytes($tagLen)
          $cipherLen = $br.ReadInt64()
          $cipherText = $br.ReadBytes([int]$cipherLen)
          $br.Close()

          $pkcs8 = [IO.File]::ReadAllBytes($pk8Path)
          $dec = [System.Security.Cryptography.MLKem]::ImportPkcs8PrivateKey($pkcs8)
          $shared = New-Object byte[] 32
          $dec.Decapsulate($ct, $shared)
          Write-Host "Decapsulation succeeded (shared secret obtained)."
          $dec.Dispose()

          $aesKey = [System.Security.Cryptography.HKDF]::DeriveKey(
            [System.Security.Cryptography.HashAlgorithmName]::SHA256,
            $shared,
            32,
            $null,
            $null
          )

          $aes = [System.Security.Cryptography.AesGcm]::new($aesKey)
          $plain = New-Object byte[] ($cipherText.Length)
          $aes.Decrypt($nonce, $cipherText, $tag, $plain, $null)
          Write-Host "AES-GCM decryption successful (plaintext size: $($plain.Length) bytes)."
          $aes.Dispose()

          $decrypted7z = Join-Path $decryptDir 'decrypted.7z'
          [IO.File]::WriteAllBytes($decrypted7z, $plain)
          Write-Host "Wrote decrypted archive: $decrypted7z"

          $sevenZipExe = "C:\Program Files\7-Zip\7z.exe"
          if (-not $sevenZipExe) { throw "7z executable not found" }

          if (-not $env:IL2CPPASSEMBLIES7ZIPPASSWORD) { throw "Environment secret IL2CPPASSEMBLIES7ZIPPASSWORD not set." }

          $args = @(
            'x',
            '-y',
            "-p$($env:IL2CPPASSEMBLIES7ZIPPASSWORD)",
            "-o$($outExtractDir)",
            $decrypted7z
          )

          Write-Host "Extracting decrypted archive to: $outExtractDir"
          $proc = Start-Process -FilePath $sevenZipExe -ArgumentList $args -Wait -NoNewWindow -PassThru
          if ($proc.ExitCode -ne 0) { throw "7z extraction failed with exit code $($proc.ExitCode)." }
          Write-Host "Extraction completed successfully."
          
          Remove-Item -Path $pk8Path -ErrorAction SilentlyContinue
          Remove-Item Env:PK8_B64 -ErrorAction SilentlyContinue

          $finalPath = Join-Path $env:LIBSDIRPATH "MelonLoader" "Il2CppAssemblies"
          New-Item $finalPath -ItemType Directory -Force
          Move-Item -Path "$($outExtractDir)\stuff\*" -Destination $finalPath -Force -ErrorAction Stop

          Set-Location ..
          Remove-Item $unpackDir -Recurse -Force
          Remove-Item $assemblyParent -Recurse -Force
          Remove-Item $outExtractDir -Recurse -Force

      - name: Setup .NET SDK 6.0
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: '6.0.x'
        
      # - name: Update & clean workloads (Only run if needed)
      #   continue-on-error: true
      #   run: |
      #     dotnet workload list
      #     dotnet workload update
      #     dotnet workload clean

      - name: Build
        run: dotnet build --configuration Release --no-self-contained -o "${{ vars.DLLNAME_NO_EXT }}\bin\Release" /p:LIBSDIRPATH=${{ env.LIBSDIRPATH }}
      
      - name: Test
        run: dotnet test --configuration Release --no-build --no-restore --verbosity normal /p:LIBSDIRPATH=${{ env.LIBSDIRPATH }}

      - name: Artifact setup
        if: ${{ env.DLLVERSION != '' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $binPath = "${{ vars.DLLNAME_NO_EXT }}\bin\Release"
          New-Item -ItemType Directory -Force -Path $binPath\artifactsetup\Mods
          Move-Item -Path $binPath\${{ vars.DLLNAME_NO_EXT }}.dll -Destination $binPath\artifactsetup\Mods
          Copy-Item -Path CHANGELOG.md -Destination $binPath\artifactsetup
          Copy-Item -Path README.md -Destination $binPath\artifactsetup
          Copy-Item -Path icon.png -Destination $binPath\artifactsetup
          Copy-Item -Path LICENSE.txt -Destination $binPath\artifactsetup
          Copy-Item -Path manifest.json -Destination $binPath\artifactsetup
          Write-Output "BINPATH=$binPath" >> $env:GITHUB_ENV
          ls -R $binPath\artifactsetup

      - name: Upload build artifact
        if: ${{ env.DLLVERSION != '' }}
        uses: actions/upload-artifact@v6
        with:
         name: ninjaguardian-${{ vars.DLLNAME_NO_EXT }}-${{ env.DLLVERSION }}
         path: ${{ env.BINPATH }}\artifactsetup

  release:
    needs: [check, build]
    runs-on: ubuntu-latest
    environment: publish
    permissions:
      contents: write
    env:
      DLLVERSION: ${{ needs.check.outputs.dllversion }}
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - uses: actions/checkout@v6
        with:
          sparse-checkout: CHANGELOG.md

      - name: Download build artifact
        uses: actions/download-artifact@v7
        with:
          name: ninjaguardian-${{ vars.DLLNAME_NO_EXT }}-${{ env.DLLVERSION }}
          path: artifact-download

      - name: Zip artifact
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          Compress-Archive -Path artifact-download\* -DestinationPath ninjaguardian-${{ vars.DLLNAME_NO_EXT }}-${{ env.DLLVERSION }}.zip

      - name: Extract changelog for release
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $version = "v${{ env.DLLVERSION }}"
          $lines = Get-Content CHANGELOG.md

          $startIndex = -1
          for ($i = 0; $i -lt $lines.Length; $i++) {
            if ($lines[$i] -match "^# $version") {
              $startIndex = $i
              break
            }
          }

          if ($startIndex -eq -1) {
            Write-Error "Version $version not found in CHANGELOG.md"
            exit 1
          }

          $endIndex = -1
          for ($j = $startIndex + 1; $j -lt $lines.Length; $j++) {
            if ($lines[$j] -match "^# v") {
              $endIndex = $j
              break
            }
          }
          if ($endIndex -eq -1) {
            $endIndex = $lines.Length
          }

          $changelogLines = $lines[($startIndex+1)..($endIndex-1)] | Where-Object { $_ -ne "" }

          $body = $changelogLines -join "`n"

          Write-Output "body<<EOF" >> $env:GITHUB_ENV
          Write-Output $body >> $env:GITHUB_ENV
          Write-Output "EOF" >> $env:GITHUB_ENV
          Write-Host "$body"

      - name: Create GitHub Release and upload artifact
        uses: softprops/action-gh-release@v2
        with:
          files: ninjaguardian-${{ vars.DLLNAME_NO_EXT }}-${{ env.DLLVERSION }}.zip
          body: ${{ env.body }}
